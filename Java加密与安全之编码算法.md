### Java加密与安全之编码算法 ###

1. `URL`编码：`URL`编码是浏览器发送数据给服务器时使用的编码，它通常附加在`URL`的参数部分，之所以需要`URL`编码，是出于兼容性的考虑，很多服务器只识别`ASCII`字符，但如果`URL`中包含中文，日文等字符，转换规则如下：

   ```text
   1.如果字符是A-Z,a-z,0-9以及-,_,.*，则保持不变;
   2.如果是其他字符，先转换为UTF-8编码，然后对每个字节以%xx表示。
   ```

   Java标准库提供了一个`URLEncoder`类来对任意字符串进行`URL`编码：

   ```java
   public class Main {
       public static void main(String[] args) {
           String encoded = URLEncoder.encode("中文!", StandardCharsets.UTF_8);
           System.out.println(encoded);
       }
   }
   ```

   和标准的`URL`编码稍有不同，`URLEncoder`把空格字符编码成`+`,而现在的`URL`编码要求空格被编码为`%20`,但是服务器对于这两种情况都可以处理。**注意`URL`编码不是加密算法**

2. `Base64编码`:`URL`编码是对字符进行编码，表示成`%xx`的形式，而`Base64`编码是对二进制数据进行编码,表示成文本格式。

   `Base64`把任意长度的二进制数据转化为文本，且只包含`A-Z`,`a-z`,`0-9`,`+`,`/`,`=`这些字符。它的原理是把`3`字节的二进制数据按`6`bit一组，用`4`个·`int`整数表示，然后查表，把`int`整数用索引对应到字符，得到编码后的字符串。

   举个栗子：3个`byte`数据分别是`e4`,`b8`,`ad`,按`6bit`分组得到`39`,`0b`,`22`和`2d`:

   ```text
   ┌───────────────┬───────────────┬───────────────┐
   │      e4       │      b8       │      ad       │
   └───────────────┴───────────────┴───────────────┘
   ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
   │1│1│1│0│0│1│0│0│1│0│1│1│1│0│0│0│1│0│1│0│1│1│0│1│
   └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
   ┌───────────┬───────────┬───────────┬───────────┐
   │    39     │    0b     │    22     │    2d     │
   └───────────┴───────────┴───────────┴───────────┘
   ```

   因为`6`位整数的范围总是`0~63`k,所以能用`64`字符表示：字符`A-Z`对应索引`0-25`,字符`a-z`对应索引`26-51`,字符`0-9`对应索引`52-61`，最后两个索引`62`,`63`分别用字符`+`和`/`表示。

   在Java中，二进制数据就是`byte[]`数组·，`Java`提供了`Base64`来对`byte[]`数组进行编解码：

   ```java
   //编码例子
   public class Main {
       public static void main(String[] args) {
           byte[] input = new byte[] { (byte) 0xe4, (byte) 0xb8, (byte) 0xad };
           String b64encoded = Base64.getEncoder().encodeToString(input);
           System.out.println(b64encoded);
       }
   }
   //解码例子
   public class Main {
       public static void main(String[] args) {
           byte[] output = Base64.getDecoder().decode("5Lit");
           System.out.println(Arrays.toString(output)); // [-28, -72, -83]
       }
   }
   ```

   学到这里，内心不免会有疑问：如果输入的`byte[]`数组长度不是`3`的整数倍该怎么办？这时，如果细心的话会发现`Base64`编码后可以包含`=`，但是索引对应的字符中却没有`=`，怎么回事？其实，`=`就是用来解决`byte[]`数组长度不是`3`的倍数这个问题，不是`3`的倍数，就把它·变成`3`的倍数，在末尾补一个或者两个`0x00`，编码后如果在结尾加一个`=`表示补充了一个`0x00`，加两个表示补充了2个`0x00`，解码时，去掉结尾的一个或两个`0x00`即可。实际上，因为解码后的长度加上`=`总是4的倍数，所以即使不加`=`也可以计算出原始输入的`byte[]`。`Base64`**编码**的时候可以用`withourPadding()`去掉`=`,解码出来结果是一样的：

   因为标准的`Base64`编码会出现`+`,`/`,`=`,所以不适合把`Base64`编码后的字符串放到`URL`中，不过一种针对`URL`的`Base64`编码可以在`URL`中使用`Base64`编码，它仅仅是把`+`变成`-`,`/`变成`_`。

   `Base64`编码的目的是把二进制数据变成文本格式，这样在很多文本中就可以处理二进制数据了，例如：电子邮件协议就是文本协议，要在电子邮件中添加一个二进制文件，就可以使用`Base64`编码，然后以文本形式传送。**`Base64`编码的缺点是传输效率会降低，因为它把原始数据长度增加了`1/3`**。如果要把`Base64`的64字符编码表换成32个，48个，58个，就可以使用`Base32`,`Base48`,`Base58`编码，**字符越少，传输效率就会越低**。